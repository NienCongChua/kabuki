import { chooseAnswer } from "./scripts/chooseAnswer";
import { chooseWord } from "./scripts/chooseWord";
import { fillBlank } from "./scripts/fillBlank";
import { vocabulary } from "./scripts/vocabulary";
import { writeWord } from "./scripts/writeWord";
import { sleep } from "./utils/sleep";

// T√≠nh to√°n th·ªùi gian c√≤n l·∫°i ch√≠nh x√°c t·ª´ timer state
function calculateActualRemainingTime(): number {
  if (!currentTimerState.isRunning || !currentTimerState.autoMode) {
    return 0;
  }

  // T√≠nh th·ªùi gian ƒë√£ tr√¥i qua t·ª´ khi start
  const elapsed = Math.floor((Date.now() - currentTimerState.startTime) / 1000);
  const remaining = Math.max(0, currentTimerState.delay - elapsed);

  return remaining;
}

// Sleep v·ªõi ki·ªÉm tra state m·ªói 100ms
function sleepWithStateCheck(seconds: number): Promise<boolean> {
  console.log("‚è≥ [Content] sleepWithStateCheck b·∫Øt ƒë·∫ßu ch·ªù", seconds, "gi√¢y");

  return new Promise((resolve) => {
    let elapsed = 0;
    const interval = 100; // Check every 100ms
    let checkCount = 0;

    const checkInterval = setInterval(() => {
      checkCount++;

      // Log m·ªói 10 l·∫ßn check (1 gi√¢y)
      if (checkCount % 10 === 0) {
        console.log("‚è≥ [Content] ƒê√£ ch·ªù", elapsed / 1000, "gi√¢y, c√≤n", (seconds * 1000 - elapsed) / 1000, "gi√¢y");
        console.log("‚è≥ [Content] State hi·ªán t·∫°i - autoMode:", currentTimerState.autoMode, "isRunning:", currentTimerState.isRunning);
      }

      // Ki·ªÉm tra n·∫øu b·ªã d·ª´ng
      if (!currentTimerState.autoMode || !currentTimerState.isRunning) {
        console.log("üõë [Content] sleepWithStateCheck b·ªã d·ª´ng - State thay ƒë·ªïi");
        console.log("üõë [Content] autoMode:", currentTimerState.autoMode, "isRunning:", currentTimerState.isRunning);
        clearInterval(checkInterval);
        resolve(false); // B·ªã d·ª´ng
        return;
      }

      elapsed += interval;
      if (elapsed >= seconds * 1000) {
        console.log("‚úÖ [Content] sleepWithStateCheck ho√†n th√†nh sau", elapsed / 1000, "gi√¢y");
        clearInterval(checkInterval);
        resolve(true); // Ho√†n th√†nh
      }
    }, interval);
  });
}

// Bi·∫øn l∆∞u tr·∫°ng th√°i timer
let currentTimerState = {
  isRunning: false,
  delay: 60,
  startTime: 0,
  autoMode: false,
  remainingTime: 60,
  currentTaskId: null as string | null,
  pausedTime: 0
};

// Bi·∫øn ƒë·ªÉ l∆∞u state backup
let lastKnownGoodState = { ...currentTimerState };

// Ki·ªÉm tra ƒë·ªãnh k·ª≥ state v√† kh√¥i ph·ª•c n·∫øu c·∫ßn
setInterval(() => {
  // N·∫øu autoMode b·ªã t·∫Øt b·∫•t ng·ªù trong khi ƒëang ch·∫°y
  if (lastKnownGoodState.autoMode && lastKnownGoodState.isRunning &&
      (!currentTimerState.autoMode || !currentTimerState.isRunning)) {

    console.log("üîÑ [Content] Ph√°t hi·ªán state b·ªã thay ƒë·ªïi b·∫•t ng·ªù trong interval check");
    console.log("üîÑ [Content] Last good state:", lastKnownGoodState);
    console.log("üîÑ [Content] Current state:", currentTimerState);

    // Th·ª≠ sync l·∫°i state t·ª´ background
    if (chrome.runtime?.sendMessage) {
      chrome.runtime.sendMessage({ action: "getState" }, (response) => {
        if (response?.success && response.state) {
          console.log("üîÑ [Content] Sync state t·ª´ background:", response.state);
          currentTimerState = response.state;
        }
      });
    }
  }

  // C·∫≠p nh·∫≠t backup state n·∫øu autoMode ƒëang b·∫≠t
  if (currentTimerState.autoMode && currentTimerState.isRunning) {
    lastKnownGoodState = { ...currentTimerState };
  }
}, 5000); // Ki·ªÉm tra m·ªói 5 gi√¢y

const getTaskClassList = () => {
  return document.querySelector<HTMLElement>("#mbody")?.firstElementChild?.classList;
};

async function onMutation(dtk: string) {
  console.log("üéØ [Content] onMutation b·∫Øt ƒë·∫ßu v·ªõi DTK:", dtk);
  console.log("üéØ [Content] Current timer state:", currentTimerState);

  let btnSubmit = document.querySelector<HTMLElement>(`button[dtk2="${dtk}"]`);
  let count = 0;
  while (btnSubmit === null) {
    if (count == 10) {
      console.log("‚ùå [Content] Kh√¥ng t√¨m th·∫•y button submit sau 10 l·∫ßn th·ª≠, reload trang");
      window.location.reload();
    }
    btnSubmit = document.querySelector<HTMLElement>(`button[dtk2="${dtk}"]`);
    await sleep(1);
    count++;
  }

  console.log("üéØ [Content] T√¨m th·∫•y button submit:", btnSubmit);
  console.log("üéØ [Content] Button disabled?", btnSubmit.hasAttribute("disabled"));

  if (!btnSubmit.hasAttribute("disabled")) {
    // Ki·ªÉm tra auto mode v√† running state
    console.log("üîç [Content] Ki·ªÉm tra ƒëi·ªÅu ki·ªán auto mode:");
    console.log("üîç [Content] autoMode:", currentTimerState.autoMode);
    console.log("üîç [Content] isRunning:", currentTimerState.isRunning);

    if (!currentTimerState.autoMode || !currentTimerState.isRunning) {
      console.log("üõë [Content] KH√îNG TH·ª∞C HI·ªÜN - Auto mode t·∫Øt ho·∫∑c timer kh√¥ng ch·∫°y");
      console.log("üõë [Content] autoMode:", currentTimerState.autoMode, "isRunning:", currentTimerState.isRunning);
      return; // Ch·ªâ ch·∫°y khi c·∫£ autoMode v√† isRunning ƒë·ªÅu true
    }

    console.log("‚úÖ [Content] ƒêi·ªÅu ki·ªán ƒë·∫°t - Ti·∫øp t·ª•c th·ª±c hi·ªán task");

    // T√≠nh to√°n th·ªùi gian ch·ªù ch√≠nh x√°c
    const actualRemainingTime = calculateActualRemainingTime();
    console.log("üïê Timer State:", {
      delay: currentTimerState.delay,
      startTime: currentTimerState.startTime,
      currentTime: Date.now(),
      elapsed: Math.floor((Date.now() - currentTimerState.startTime) / 1000),
      actualRemainingTime: actualRemainingTime
    });

    if (actualRemainingTime > 0) {
      console.log("‚è≥ Extension s·∫Ω ch·ªù", actualRemainingTime, "gi√¢y n·ªØa");
      const success = await sleepWithStateCheck(actualRemainingTime);
      if (!success) {
        console.log("‚ùå B·ªã d·ª´ng trong qu√° tr√¨nh ch·ªù");
        return; // B·ªã d·ª´ng trong qu√° tr√¨nh ƒë·ª£i
      }
    } else {
      console.log("‚ö° Th·ªùi gian ƒë√£ h·∫øt, th·ª±c hi·ªán ngay l·∫≠p t·ª©c");
    }

    // Ki·ªÉm tra l·∫°i state tr∆∞·ªõc khi th·ª±c hi·ªán
    console.log("üîç [Content] Ki·ªÉm tra l·∫°i state tr∆∞·ªõc khi th·ª±c hi·ªán:");
    console.log("üîç [Content] autoMode:", currentTimerState.autoMode, "isRunning:", currentTimerState.isRunning);

    if (!currentTimerState.autoMode || !currentTimerState.isRunning) {
      console.log("üõë [Content] D·ª™NG - State ƒë√£ thay ƒë·ªïi trong qu√° tr√¨nh ch·ªù");
      return;
    }

    // Th·ª±c hi·ªán b√†i t·∫≠p
    console.log("üöÄ [Content] B·∫Øt ƒë·∫ßu th·ª±c hi·ªán task");
    executeTask(btnSubmit);
  } else {
    console.log("‚è∏Ô∏è [Content] Button submit b·ªã disabled, kh√¥ng th·ªÉ th·ª±c hi·ªán");
  }
}

// T√°ch logic th·ª±c hi·ªán b√†i t·∫≠p ra function ri√™ng
function executeTask(btnSubmit: HTMLElement) {
  console.log("üöÄ [Content] executeTask b·∫Øt ƒë·∫ßu");

  const classList = getTaskClassList();
  const taskType = classList!.item(1)!.toString();

  console.log("üöÄ [Content] Task type:", taskType);
  console.log("üöÄ [Content] Class list:", classList);

  if (taskType == "default") {
    console.log("üöÄ [Content] Th·ª±c hi·ªán vocabulary task");
    vocabulary(btnSubmit);
  }
  if (taskType == "audio-write-word" || taskType == "pronunciation-write-word") {
    console.log("üöÄ [Content] Th·ª±c hi·ªán writeWord task");
    writeWord();
  }
  if (
    taskType == "fill-reading-word-blank" ||
    taskType == "fill-listening-write-answer" ||
    taskType == "fill-vocabulary-block-blank" ||
    taskType == "fill-grammar-word-blank"
  ) {
    console.log("üöÄ [Content] Th·ª±c hi·ªán fillBlank task");
    fillBlank(btnSubmit);
  }
  if (taskType == "choose-listening-choose-answer" || taskType == "choose-reading-choose-answer") {
    console.log("üöÄ [Content] Th·ª±c hi·ªán chooseAnswer task");
    chooseAnswer(btnSubmit);
  }
  if (taskType == "view-content") {
    console.log("üöÄ [Content] Th·ª±c hi·ªán view-content task");
    sleep(3).then(() => btnSubmit.click());
  }
  if (taskType == "upload-content") {
    console.log("üöÄ [Content] Upload task - ch∆∞a implement");
  }
  if (
    taskType == "image-choose-word" ||
    taskType == "audio-choose-word" ||
    taskType == "word-choose-meaning" ||
    taskType == "audio-choose-image"
  ) {
    console.log("üöÄ [Content] Th·ª±c hi·ªán chooseWord task");
    chooseWord();
  }
}

chrome.runtime.onMessage.addListener(function (request, _sender, sendResponse) {
  console.log("üì® [Content] Nh·∫≠n message t·ª´ background:", request);

  const dtk = request.id;

  // C·∫≠p nh·∫≠t timer state n·∫øu c√≥
  if (request.timerState) {
    const oldState = { ...currentTimerState };
    currentTimerState = request.timerState;

    console.log("üîÑ [Content] C·∫≠p nh·∫≠t timer state:");
    console.log("üîÑ [Content] State c≈©:", oldState);
    console.log("üîÑ [Content] State m·ªõi:", currentTimerState);

    // Ki·ªÉm tra n·∫øu autoMode b·ªã t·∫Øt b·∫•t ng·ªù
    if (oldState.autoMode && !currentTimerState.autoMode) {
      console.log("üõë [Content] AUTO MODE B·ªä T·∫ÆT! T·ª´ true -> false");
      console.log("üõë [Content] C√≥ th·ªÉ do tab navigation ho·∫∑c extension restart");

      // C·∫¢NH B√ÅO: ƒê√¢y c√≥ th·ªÉ l√† l·ªói kh√¥ng mong mu·ªën
      if (oldState.isRunning && !request.action) {
        console.log("‚ö†Ô∏è [Content] C·∫¢NH B√ÅO: AutoMode b·ªã t·∫Øt trong khi ƒëang ch·∫°y task!");
        console.log("‚ö†Ô∏è [Content] ƒê√¢y c√≥ th·ªÉ l√† l·ªói do tab navigation");

        // T·ª∞ ƒê·ªòNG KH√îI PH·ª§C autoMode n·∫øu b·ªã t·∫Øt b·∫•t ng·ªù
        console.log("üîÑ [Content] Th·ª≠ kh√¥i ph·ª•c autoMode b·∫±ng c√°ch g·ª≠i message start");
        setTimeout(() => {
          if (chrome.runtime?.sendMessage) {
            chrome.runtime.sendMessage({ action: "start" }, (response) => {
              if (response?.success) {
                console.log("‚úÖ [Content] ƒê√£ kh√¥i ph·ª•c autoMode th√†nh c√¥ng");
              } else {
                console.log("‚ùå [Content] Kh√¥ng th·ªÉ kh√¥i ph·ª•c autoMode");
              }
            });
          }
        }, 1000); // Ch·ªù 1 gi√¢y r·ªìi th·ª≠ kh√¥i ph·ª•c
      }
    }

    // Ki·ªÉm tra n·∫øu isRunning b·ªã t·∫Øt
    if (oldState.isRunning && !currentTimerState.isRunning) {
      console.log("‚è∏Ô∏è [Content] TIMER B·ªä D·ª™NG! T·ª´ true -> false");
    }
  }

  if (dtk) {
    console.log("üéØ [Content] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω task v·ªõi DTK:", dtk);
    onMutation(dtk);
  } else if (request.action === "stateUpdate") {
    console.log("üîÑ [Content] Nh·∫≠n state update t·ª´ broadcast");
  }

  sendResponse({ success: true });
});
